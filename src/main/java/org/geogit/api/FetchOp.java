/* Copyright (c) 2011 TOPP - www.openplans.org. All rights reserved.
 * This code is licensed under the LGPL 2.1 license, available at the root
 * application directory.
 */
package org.geogit.api;

import java.util.Map;

import org.geogit.api.config.RefIO;
import org.geogit.api.config.RemoteConfigObject;
import org.geogit.repository.Repository;
import org.geogit.repository.remote.IRemote;
import org.geogit.repository.remote.RemoteRepositoryFactory;
import org.geogit.repository.remote.payload.IPayload;

import com.google.common.base.Preconditions;

/**
 * Download objects and refs from another repository, currently only works for fast forwards from
 * HEAD of remote. 
 * 
 * http://git-scm.com/gitserver.txt - This document doesn't seem to be available anymore at 
 * this location.
 * 
 * @author jhudson
 */
public class FetchOp extends AbstractGeoGitOp<FetchResult> {

	/**
	 * The remote(s) this repository is cloning from
	 */
    private Map<String, RemoteConfigObject> remotes;

    public FetchOp( Repository repository, Map<String, RemoteConfigObject> remotes ) {
        super(repository);
        this.remotes = remotes;
    }

    /**
     * For each remote_service : 
     * 		get the refs/remotes/REF_NAME/REMOTE(S)
	 *			For ALL res/remotes/REF_NAME/REMOTE_ID send remote_service (REF_NAMES<REMOTE_ID> receive pack file with 
	 *				1. REMOTE_NAME <commits> 
	 *				2. Add commits to object DB 
	 *				3. update ref in ref DB 
	 *				4. write config
     */
    @Override
    public FetchResult call() throws Exception {
    	/*
    	 * The Result object holds a counter on all the operations that occur on a fetch 
    	 *  this will be used by a pull operation to identify if it needs to do a merge. 
    	 */
    	FetchResult result = new FetchResult();
    	
    	/*for each remote configuration we have do:*/
        for( RemoteConfigObject remote : remotes.values() ) {
            if (remote != null) { /*can never be too careful*/
            	
            	/*
            	 * An interface to a remote geogit server - this can be either a local 'remote' 
            	 * (local to the hard disk drive) or a remote remote (url based)
            	 */
            	IRemote remoteRepo = RemoteRepositoryFactory.createRemoteRepositroy(remote.getUrl());
            	Preconditions.checkNotNull(remoteRepo);

            	/*
            	 * The payload is generated by the remote object - The remote object knows how to 
            	 * communicate with the remote geogit repository - local or url based.
            	 * 
            	 * The payload sent back to be applied to the specified named branch
            	 */
            	IPayload payload = remoteRepo.requestFetchPayload(RefIO.getRemoteList(getRepository().getRepositoryHome(),remote.getName()));
            	
            	/*
            	 * The utilities object which can apply the payload to a branch
            	 */
            	PayloadUtil payloadUtil = new PayloadUtil(getRepository());
                result.merge(payloadUtil.applyPayloadTo(remote.getName(), payload));
                /* 
                 * clean up the remote object - this is to release any connections to the 
                 * repositories the remote object may have   
                 */
                remoteRepo.dispose();
            }
        }
        return result;
    }
}
